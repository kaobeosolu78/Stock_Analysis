from pytrends.request import TrendReq
import pickle
import pytrends
import pandas as pd
from pandas.tseries.offsets import BDay
import plotly.plotly as py
from scipy import stats
from plotly import tools
import os.path
import plotly.graph_objs as goo
import plotly.offline
import numpy as np
from datetime import datetime,timedelta
import requests
import alpha_vantage
import time
from bdateutil import isbday
import holidays


def load_obj(datatype):
    with open("{}".format(datatype) + '.pkl', 'rb') as f:
        return pickle.load(f)

def get_google_trends(trends,state,new_data):
    kw_list = trends
    semp = False
    if new_data == 1:
        semp = True
        alll = {}
        cruc = ["all","today 5-y","today 3-m"]
        for k in range(3):
            pytrends = TrendReq(hl='en-US', tz=360)
            pytrends.build_payload(kw_list, cat=0, timeframe=cruc[k], geo='', gprop='')
            if state == True:
                dub = pytrends.get_historical_interest(kw_list, year_start=2018, month_start=8, day_start=4, hour_start=0, year_end=2018, month_end=8, day_end=14, hour_end=0, cat=0, geo='', gprop='')
            elif state == False:
                dub = pytrends.interest_over_time()
            alll[cruc[k]] = dub

        pick_out = open("trendtest-{}.pkl".format(kw_list[0]),"wb")
        pickle.dump(alll,pick_out,pickle.HIGHEST_PROTOCOL)
        pick_out.close()
    else:
        pass

    trend = load_obj("trendtest-{}".format(kw_list[0]))
    return trend

mode = ["months", "weeks", "days"]
all_data = []
stount = 0
cruc = ["all", "today 5-y", "today 3-m"]
c = 1

new_data = 0
inter = 2

master = {"insy":["insy"],"cgc":["robinhood","canopy growth stock"],"innt":["robinhood","Innovate Biopharmaceuticals"],"tsla":["robinhood","td ameritrade","fidelity","schwab"]}


indexe = ["cgc"]#insy
for kw in master[indexe[0]]:#"spwr","qcom","slrc","p","alb","orcl","ge","ford","snap","rad"]:
    kw_list = [kw]
    trend = get_google_trends(kw_list,False,new_data)[cruc[inter]]
    data = []
    daters = []


    for ind,t in trend[kw_list[0]].iteritems():
        daters.append(ind)#(pd.to_datetime(datees[count])))
        data.append(t)
    #["spwr","qcom","slrc","p","alb","orcl","ge","ford","snap","rad"]

    rawprods = load_obj("stock_data")
    API_URL = "https://www.alphavantage.co/query"

    def get(index,mode):
        help = ["Monthly Time Series","Weekly Time Series","Time Series (Daily)"]
        help2 = ["TIME_SERIES_MONTHLY","TIME_SERIES_WEEKLY","TIME_SERIES_DAILY"]
        dates = []
        close = []
        volume = []
        ope = []
        high = []
        low = []
        data = {
            "function": help2[mode],
            "symbol": "{}".format(index),
            # "interval": "60min",
            "outputsize": "full",
            "datatype": "json",
            "apikey": "4PONUNLFLKWOK7UU",
            "retries": 10
        }

        try:
            dub = ((requests.get(API_URL, params=data)).json())
            datees = ((dub[help[mode]]).keys())
        except:
            try:
                dub = ((requests.get(API_URL, params=data)).json())
                datees = ((dub[help[mode]]).keys())
            except:
                print("time series error")
                return rawprods

        for key in datees:
            temp = ((dub[help[mode]])[key])["4. close"]
            close.append(temp)
            wemp = ((dub[help[mode]])[key])["5. volume"]
            volume.append(wemp)
            zemp = ((dub[help[mode]])[key])["1. open"]
            ope.append(zemp)
            hemp = ((dub[help[mode]])[key])["2. high"]
            high.append(hemp)
            remp = ((dub[help[mode]])[key])["3. low"]
            low.append(remp)

        for key in (datees):
            dates.append((key))

        return [dates, close, volume, ope, high, low]

    hount = 0
    for k in list(rawprods.keys()):
        if indexe[0] == k:
            hount += c

    if new_data == 1 and stount != 1:
        hount = 0
        stount += 1

    for k in list(rawprods.keys()):
        if k == indexe[0]:
            hount = 1

    if hount == 0:
        print ("gettin data")

        for index in indexe:
            gemp = []
            for j in range(3):
                [dates, close, volume, ope, high, low] = get(index,j)
                gemp.append({"Dates": dates, "Close": close, "Volume": volume, "Open": ope, "High": high, "Low": low})
            rawprods[index] = gemp
        for ind in indexe:
            for p in range(3):
                temp = []
                hemp = []
                remp = []
                pemp = []
                [temp.append((float(rawprods[ind][p]["Close"][k])-float(rawprods[ind][p]["Open"][k]))) for k in range(len(rawprods[ind][p]["Open"]))]
                rawprods[ind][p]["Diff"] = temp
                [hemp.append((float(rawprods[ind][p]["High"][k]) - float(rawprods[ind][p]["Low"][k]))) for k in range(len(rawprods[ind][p]["High"]))]
                rawprods[ind][p]["Hlow"] = hemp
                [pemp.append((float(rawprods[ind][p]["High"][k]) - float(rawprods[ind][p]["Open"][k]))) for k in range(len(rawprods[ind][p]["High"]))]
                rawprods[ind][p]["Potential"] = pemp
                [remp.append((float(rawprods[ind][p]["Low"][k]) - float(rawprods[ind][p]["Open"][k]))) for k in range(len(rawprods[ind][p]["High"]))]
                rawprods[ind][p]["Risk"] = remp

        for ind in indexe:
            for p in range(3):
                rawprods[ind][p]["Close"] = [((float(rawprods[ind][p]["Close"][k-1])-float(rawprods[ind][p]["Close"][k]))/float(rawprods[ind][p]["Close"][k-1])) for k in range(len(rawprods[ind][p]["Close"])) if k-1 != 0]

        pickle_out = open("stock_data.pkl".format(ind), 'wb')
        pickle.dump(rawprods, pickle_out, pickle.HIGHEST_PROTOCOL)
        pickle_out.close()

    from dateutil.relativedelta import relativedelta

    rawprods = load_obj("stock_data")[indexe[0]][inter]

    price_dates = []

    def date_range(start, end, delta):
        current = start
        if not isinstance(delta, timedelta):
            delta = relativedelta(**delta)
        while current < end:
            yield current
            current += delta

    def rawprods_diff_fixer(indexe,rawprods,tf):
        diff = rawprods["Diff"]
        dates = rawprods["Dates"]
        prods = []
        wekday = timedelta(days=0)
        dub = timedelta(days=0)

        if tf == "weeks":
            wekday = timedelta(days=(datetime.strptime(dates[len(dates)-1],"%Y-%m-%d")).weekday())
        elif tf == "days":
            dub = timedelta(days=1)


        actual_dates = list(date_range(datetime.strptime(dates[len(dates)-1], "%Y-%m-%d")+wekday, datetime.strptime(dates[0], "%Y-%m-%d")+dub, {tf:1}))[::-1]

        if tf != "days":
            return diff, actual_dates

        counter = 1
        bounter = 1
        while counter < len(diff):

            if (isbday(actual_dates[counter-1],holidays=holidays.US())) == False:
                prods.append(0)
            else:
                prods.append(diff[bounter-1])
                bounter += 1
            counter += 1

        return prods,actual_dates

    [prods,bemp] = rawprods_diff_fixer(indexe,rawprods,mode[inter])


    [data.append(0) for e in range((bemp[0]-daters[len(daters)-1]).days) if inter == 2]
    if len(data) < len(prods):
        start = (daters[0])
        end = (bemp[0])

    elif len(data) > len(prods):
        hemp = []
        start = (bemp[len(bemp)-1])
        end = (bemp[0])

        for k in range(len(bemp)):
            try:
                hemp.append(data[::-1][k])
            except:
                break

        data = hemp[::-1]

    if inter == 2:
        day = 1
    elif inter == 1:
        day = 7
    elif inter == 0:
        day = 31

    date_generated = list(date_range(start,end+timedelta(days=day),{mode[inter]:1}))



    vol = []
    switch = 0
    k=0
    while k < len(date_generated):
        if (((bemp[k]).month) == float((date_generated[len(date_generated)-1]).month) and (bemp[k].year) == float((date_generated[len(date_generated)-1]).year) and ((bemp[k]).day) == float((date_generated[len(date_generated)-1]).day)) or switch != 0:
            switch += 1
        if len(vol) == len(date_generated):
            break
        if switch != 0 or inter != 2:
            vol.append(prods[k])

        k+=1

    vol = [float(i) for i in vol]
    vol = vol[::-1]


    all_data.append(data)

def optimize(data,vol):
    temp = [0,0,0,0]
    for x in np.linspace(0,10,100):
        for v in range(len(data)):
            count = 0
            gains = []

            for k in range(0, len(data)-1):
                if (data[k]-data[k+1]) > x:
                    pass
                else:
                    if k+v < len(vol):
                        count += 1
                        gains.append(vol[k+v])
            # print(count)
            if temp[0] < sum(gains):
                temp = [sum(gains), x, v,count]
    return temp



trends = []

    # temp = optimize(trends_temp[k],prices[k])

count = -1
if len(all_data) == 1:
    trends = all_data[0]
else:
    while count < len(all_data[len(all_data)-1]):
        temp = []
        count += 1
        for t in range(len(all_data)):
            try:
                temp.append(all_data[t][count])
            except:
                pass
        try:
            trends.append(sum(temp))
        except:
            pass


    # [slope, intercept, r_value, p_value, std_err] = stats.linregress(data, vol)

print (kw)
print (len(trends))
print (len(vol))
print (len(date_generated))

temp = optimize(trends,vol)

# price_dates = date_range(date_generated[len(date_generated)-len(vol)],date_generated[len(date_generated)-1],1,"days")
# price_dates = pd.date_range(date_generated[0], date_generated[len(date_generated)-1], freq=BDay())
# vol = vol[14:]


brends = [t*.01 for t in trends]

brains = []
bates = []
bode = [30,7,1]
for k in range(0,len(trends)-1):
    if (trends[k] - trends[k + 1]) < temp[1]:
        # if k+temp[2] >= len(vol)-1:
        try:
            brains.append(vol[k+temp[2]])
            bates.append(date_generated[k+temp[2]])
        except:
            brains.append(.0078)
            bates.append(date_generated[len(date_generated) - 1] + timedelta(
                    days=(temp[2] + 1 + (k - len(date_generated))) * bode[inter]))
print (len(bates))
print(len(brains))

tell = 0
for k in brains:
    if k > 0:
        tell += 1
ratio = int(100*tell/len(brains))

fig = tools.make_subplots(rows=1, cols=1,shared_xaxes=True,shared_yaxes=True)
trace1 = goo.Scatter(x=date_generated, y=brends)
trace2 = goo.Scatter(x=date_generated, y=vol)
trace3 = goo.Scatter(x=bates,y=brains)
fig.append_trace(trace3, 1, 1)
# fig.append_trace(trace2, 2, 1)
# fig.append_trace(trace2, 3, 1)
title = "Optimal trend limit for {} if bought after {} {}: {}. increase on equity.".format(indexe[0],temp[2],mode[inter],temp[1])

plotly.offline.plot({"data": [trace3], "layout": goo.Layout(title="Net gain of ${} from {} in {} {}. Gains made {}% of the time. Rate: ${} per share per {}.".format(temp[0],indexe[0],temp[3],mode[inter],ratio,temp[0]/temp[3],mode[inter][:-1]))})
print (temp)
# plotly.offline.plot({"data": [trace1,trace2], "layout": goo.Layout(title=title)})


#create portfolio of most profitable stocks
